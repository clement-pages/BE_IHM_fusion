/* autogenerated by Processing revision 1286 on 2022-11-26 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import fr.dgac.ivy.*;
import fr.dgac.ivy.tools.*;
import gnu.getopt.*;

import java.awt.Point;
import fr.dgac.ivy.*;
import processing.sound.*;
import ddf.minim.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Palette extends PApplet {

/*
 * Palette Graphique - prélude au projet multimodal 3A SRI
 * 4 objets gérés : cercle, rectangle(carré), losange et triangle
 * (c) 05/11/2019
 * Dernière révision : 28/04/2020
 */
 




Minim minim;
AudioPlayer player;

Ivy bus_receiver; // pour recevoir le message ivy
Ivy bus_receiver2; // pour recevoir les gestes 

Click avant_dernier; // sauvegarder l'avant dernier click et la forme associee 
Click dernier; // sauvegarder la position du dernier click plus la forme associée 
int timer;

ArrayList<Forme> formes; // liste de formes stockées
FSM mae; // Finite Sate Machine
int indice_forme;
PImage sketch_icon;
String message= "";
String last_forme;


 public void setup() {
  last_forme = "banane";
  timer = 0;
  /* size commented out by preprocessor */;
  surface.setResizable(true);
  surface.setTitle("Palette multimodale");
  surface.setLocation(20,20);
  sketch_icon = loadImage("Palette.jpg");
  surface.setIcon(sketch_icon);
  
  minim = new Minim(this);
  player = minim.loadFile("MFJA.mp3");
  
  
  formes= new ArrayList(); // nous créons une liste vide
  noStroke();
  mae = FSM.INITIAL;
  indice_forme = -1;
  
  try
  {
    bus_receiver = new Ivy("demo", " demo_processing is ready", null);
    bus_receiver.start("127.255.255.255:2010");
    bus_receiver.bindMsg("^sra5 Parsed=action=(.*) forme=(.*) couleur=(.*) lieu=(.*) Confidence=(.*) NP=(.*) Num_A=(.*)", new IvyMessageListener()
    {
      public void receive(IvyClient client,String[] args)
      {
        
        try
        {
          bus_receiver.sendMsg("recu commande vocale Feedback=ok");
          command_received(args[0],args[1],args[2],args[3]);
        }
        
        catch (IvyException ie) {}  
      }        
    });
    bus_receiver.bindMsg("^OneDollarIvy Template=(.*) Confidence=(.*)", new IvyMessageListener()
    {
      public void receive(IvyClient client,String[] args)
      {
        
        try
        {
          bus_receiver.sendMsg("recu commande gestuelle Feedback=ok");
          geste_received(args[0],args[1]);
        }
        
        catch (IvyException ie) {}  
      }        
    });
    
  
  }
  catch (IvyException ie)
  {
  }
}

 public void draw() {
  background(0);
  
  if(last_forme!=null){
    fill(255,0,0);
    text(last_forme,10,50);
  }
  
  
  
  println("MAE : " + mae + " indice forme active ; " + indice_forme);
  switch (mae) {
    case INITIAL:  // Etat INITIAL
      background(255);
      fill(250,0,0);
      text("INIT",10,10);
      mae = FSM.AFFICHER_FORMES;
      break;
      
    case AFFICHER_FORMES:  // 
      affiche();
      break;   
    case ATTENTE_PAROLE:
      affiche();
      timer+=1;
      fill(255,0,0);
      text(timer,10,10);

      if(timer > 300){
        timer = 0;
        mae = FSM.AFFICHER_FORMES;
        clean();
      }
      break;
    case ATTENTE_CLIC:
      affiche();
      timer+=1;
      fill(255,0,0);
      text(timer,10,10);

      if(timer > 200){
        timer = 0;
        mae = FSM.AFFICHER_FORMES;
        clean();
      }
      break;
    case ATTENTE_GESTE:
      affiche();
      timer+=1;
      fill(255,0,0);
      text(timer,10,10);

      if(timer > 300){
        timer = 0;
        mae = FSM.AFFICHER_FORMES;
        clean();
      }
      break;
    default:
      break;
  }  
}

// fonction d'affichage des formes m
 public void affiche() {
  background(255);
  /* afficher tous les objets */
  for (int i=0;i<formes.size();i++) // on affiche les objets de la liste
    (formes.get(i)).update();
}

 public void mousePressed() { // sur l'événement clic
  Point p = new Point(mouseX,mouseY);
  avant_dernier = dernier;
  Forme derniere_forme;
  derniere_forme = null;
  
  for (int i=0;i<formes.size();i++) { // we're trying every object in the list
    // println((formes.get(i)).isClicked(p));
    if ((formes.get(i)).isClicked(p)) {
      derniere_forme = formes.get(i);
    }
  }
  dernier = new Click(p,derniere_forme);
  
  
  switch (mae) {
    case AFFICHER_FORMES:
      mae = FSM.ATTENTE_PAROLE;
      break;
    case ATTENTE_CLIC:
      Forme f = new Losange(dernier);
      if(last_forme != null){
        switch(last_forme){
          case "triangle" :
            f = new Triangle(dernier);
            break;
          case "carre" :
            f = new Rectangle(dernier);
            break;
          case "cercle" :
            f = new Cercle(dernier);
            break;
          case "MFJAAAAAAA":
            f = new Mfja(dernier);
            break;
          default:
            break;
        }
      }
      
      formes.add(f);
      break;
    default:
      break;
  }
  
  if (dernier.is_linked()){ // si le dernier click est lié à une forme
   //dernier.get_forme().setLocation(new Point(10,height-10));
  }
  if(avant_dernier != null){
    if (avant_dernier.is_linked()){
      //avant_dernier.get_forme().setLocation(new Point(10,10));
    }
  }
}


 public void keyPressed() {
  Point p = new Point(mouseX,mouseY);
  switch(key) {
    case 'r':
      Forme f= new Rectangle(p);
      formes.add(f);
      mae=FSM.AFFICHER_FORMES;
      break;
      
    case 'c':
      Forme f2=new Mfja(p);
      formes.add(f2);
      mae=FSM.AFFICHER_FORMES;
      break;
    
    case 't':
      Forme f3=new Triangle(p);
      formes.add(f3);
       mae=FSM.AFFICHER_FORMES;
      break;  
      
    case 'l':
      Forme f4=new Losange(p);
      formes.add(f4);
      mae=FSM.AFFICHER_FORMES;
      break;    
      
  }
}
/*
 * Classe Cercle
 */ 
 
public class Cercle extends Forme {
  
  int rayon;
  
  public Cercle(Point p) {
    super(p);
    this.rayon=80;
  }
  
  public Cercle(Point p, String c) {
    super(p, c);
    this.rayon=80;
  }
   
  public void update() {
    fill(this.c);
    circle((int) this.origin.getX(),(int) this.origin.getY(),this.rayon);
  }  
   
   public boolean isClicked(Point p) {
    // vérifier que le cercle est cliqué
   PVector OM= new PVector( (int) (p.getX() - this.origin.getX()),(int) (p.getY() - this.origin.getY())); 
   if (OM.mag() <= this.rayon/2)
     return(true);
   else 
     return(false);
  }
  
  public void increase() {
    this.rayon = (int)(this.rayon*1.2f);
  }
  
  public void decrease() {
    this.rayon = (int)(this.rayon*0.8f);
  }
  
  protected double perimetre() {
    return(2*PI*this.rayon);
  }
  
  protected double aire(){
    return(PI*this.rayon*this.rayon);
  }
}
class Click extends Point{
  Forme f;
  
  Click(Point p, Forme f){
    super(p.x,p.y);
    this.f = f;
  }
  
  Click(int x, int y, Forme f){
    super(x,y);
    this.f = f;
  }
  
   public boolean is_linked(){
    if(this.f == null){
      return false;
    }
    return true;
  }
  
  
   public Forme get_forme(){
    return this.f;
  }
  
}
/*
 * Enumération de a Machine à Etats (Finite State Machine)
 *
 *
 */
 
public enum FSM {
  INITIAL, /* Etat Initial */ 
  AFFICHER_FORMES, 
  ATTENTE_PAROLE,
  ATTENTE_GESTE,
  ATTENTE_CLIC,
}
/*****
 * Création d'un nouvelle classe objet : Forme (Cercle, Rectangle, Triangle
 * 
 * Date dernière modification : 28/10/2019
 */

abstract class Forme {
 Point origin;
 int c;
 
 Forme(Point p) {
   this.origin=p;
   this.c = color(127);
 }
 
 Forme(Point p, String c){
   this.origin = p;
   switch(c){
     case "ROUGE" : this.c = color(255, 0, 0);  break;
     case "VERT"  : this.c = color(0, 255, 0);  break;
     case "BLEU"  : this.c = color(0, 0, 255);  break;
     default: this.c = color(127);
   }
 }
 
  public void setColor(int c) {
   this.c=c;
 }
 
  public int getColor(){
   return(this.c);
 }
 
  public abstract void update();
 
  public abstract void increase();
  public abstract void decrease();
 
  public Point getLocation() {
   return(this.origin);
 }
 
  public void setLocation(Point p) {
   this.origin = p;
 }
 
  public abstract boolean isClicked(Point p);
 
 // Calcul de la distance entre 2 points
 protected double distance(Point A, Point B) {
    PVector AB = new PVector( (int) (B.getX() - A.getX()),(int) (B.getY() - A.getY())); 
    return(AB.mag());
 }
 
 protected abstract double perimetre();
 protected abstract double aire();
}
/*
 * Classe Losange
 */ 
 
public class Losange extends Forme {
  Point A, B,C,D;
  
  public Losange(Point p) {
    super(p);
    // placement des points
    placerPoints(p);
  }
  
  public Losange(Point p, String c){
    super(p, c);
    // placement des points
    placerPoints(p);
  }
  
  public void placerPoints(Point p){
    A = new Point();    
    A.setLocation(p);
    B = new Point();    
    B.setLocation(A);
    C = new Point();  
    C.setLocation(A);
    D = new Point();
    D.setLocation(A);
    B.translate(40,60);
    D.translate(-40,60);
    C.translate(0,120);
  }
  
   public void setLocation(Point p) {
      super.setLocation(p);
      // redéfinition de l'emplacement des points
      A.setLocation(p);   
      B.setLocation(A);  
      C.setLocation(A);
      D.setLocation(A);
      B.translate(40,60);
      D.translate(-40,60);
      C.translate(0,120);   
  }
  
  public void update() {
    fill(this.c);
    quad((float) A.getX(), (float) A.getY(), (float) B.getX(), (float) B.getY(), (float) C.getX(), (float) C.getY(),  (float) D.getX(),  (float) D.getY());
  }  
  
   public boolean isClicked(Point M) {
    // vérifier que le losange est cliqué
    // aire du rectangle AMD + AMB + BMC + CMD = aire losange  
    if (round( (float) (aire_triangle(A,M,D) + aire_triangle(A,M,B) + aire_triangle(B,M,C) + aire_triangle(C,M,D))) == round((float) aire()))
      return(true);
    else 
      return(false);  
  }
  
  public void increase(){
    int factX = (int)((B.getX()-D.getX())*0.1f);
    int factY = (int)((C.getY()-A.getY())*0.1f);
    B.translate(factX,0);
    D.translate(-factX,0);
    C.translate(0,factY); 
    A.translate(0,-factY);
  }
  
  public void decrease(){
    int factX = (int)((B.getX()-D.getX())*0.1f);
    int factY = (int)((C.getY()-A.getY())*0.1f);
    B.translate(-factX,0);
    D.translate(factX,0);
    C.translate(0,-factY); 
    A.translate(0,factY);
  }
  
  protected double perimetre() {
    //
    PVector AB= new PVector( (int) (B.getX() - A.getX()),(int) (B.getY() - A.getY())); 
    PVector BC= new PVector( (int) (C.getX() - B.getX()),(int) (C.getY() - B.getY())); 
    PVector CD= new PVector( (int) (D.getX() - C.getX()),(int) (D.getY() - C.getY())); 
    PVector DA= new PVector( (int) (A.getX() - D.getX()),(int) (A.getY() - D.getY())); 
    return( AB.mag()+BC.mag()+CD.mag()+DA.mag()); 
  }
  
  protected double aire(){
    PVector AC= new PVector( (int) (C.getX() - A.getX()),(int) (C.getY() - A.getY())); 
    PVector BD= new PVector( (int) (D.getX() - B.getX()),(int) (D.getY() - B.getY())); 
    return((AC.mag()*BD.mag())/2);
  } 
  
  private double perimetre_triangle(Point I, Point J, Point K) {
    //
    PVector IJ= new PVector( (int) (J.getX() - I.getX()),(int) (J.getY() - I.getY())); 
    PVector JK= new PVector( (int) (K.getX() - J.getX()),(int) (K.getY() - J.getY())); 
    PVector KI= new PVector( (int) (I.getX() - K.getX()),(int) (I.getY() - K.getY())); 
    
    return( IJ.mag()+JK.mag()+KI.mag()); 
  }
   
  // Calcul de l'aire d'un triangle par la méthode de Héron 
  private double aire_triangle(Point I, Point J, Point K){
    double s = perimetre_triangle(I,J,K)/2;
    double aire = s*(s-distance(I,J))*(s-distance(J,K))*(s-distance(K,I));
    return(sqrt((float) aire));
  }
}

/*
 * Classe Rectangle
 */ 
 
public class Mfja extends Forme {
  PImage sprite;
  PImage originSprite;
  int longueur;
  int widthMfja;
  int heightMfja;
  
  public Mfja(Point p) {
    super(p);
    creerMfja();
  }
  
  public Mfja(Point p, String c){
    super(p, c);
    creerMfja();
  }
  
  public void creerMfja(){
    originSprite = loadImage("data/MFJA.png");
    this.longueur=60;
    this.widthMfja = 176;
    this.heightMfja = 100;
    sprite = originSprite.copy();
    sprite.resize(this.widthMfja,this.heightMfja);
  }
   
  public void update() {
    fill(this.c);
    rect((int) this.origin.getX(),(int) this.origin.getY(),this.widthMfja,this.heightMfja);
    image(sprite,this.origin.x,this.origin.y);
  }  
  
  public void increase(){
    this.widthMfja = (int) (this.widthMfja*1.2f);
    this.heightMfja = (int) (this.heightMfja*1.2f);
    sprite = originSprite.copy();
    sprite.resize(this.widthMfja,this.heightMfja);
  }
  
  public void decrease(){
    this.widthMfja = (int) (this.widthMfja*0.8f);
    this.heightMfja = (int) (this.heightMfja*0.8f);
    sprite = originSprite.copy();
    sprite.resize(this.widthMfja,this.heightMfja);
  }
  
   public boolean isClicked(Point p) {
    return(p.x > origin.x && p.x < (origin.x+sprite.width) && p.y > origin.y && p.y < (origin.y + sprite.height));
  }
  
  // Calcul du périmètre du carré
  protected double perimetre() {
    return(this.longueur*4);
  }
  
  protected double aire(){
    return(this.longueur*this.longueur);
  }
}
/*
 * Classe Rectangle
 */ 
 
public class Rectangle extends Forme {
  
  int longueur;
  
  public Rectangle(Point p) {
    super(p);
    this.longueur=60;
  }
  
  public Rectangle(Point p, String c) {
    super(p, c);
    this.longueur=60;
  }
   
  public void update() {
    fill(this.c);
    square((int) this.origin.getX(),(int) this.origin.getY(),this.longueur);
  }  
  
    public void increase() {
    this.longueur = (int)(this.longueur*1.2f);
  }
  
  public void decrease() {
    this.longueur = (int)(this.longueur*0.8f);
  }
  
   public boolean isClicked(Point p) {
    int x= (int) p.getX();
    int y= (int) p.getY();
    int x0 = (int) this.origin.getX();
    int y0 = (int) this.origin.getY();
    
    // vérifier que le rectangle est cliqué
    if ((x>x0) && (x<x0+this.longueur) && (y>y0) && (y<y0+this.longueur))
      return(true);
    else  
      return(false);
  }
  
  // Calcul du périmètre du carré
  protected double perimetre() {
    return(this.longueur*4);
  }
  
  protected double aire(){
    return(this.longueur*this.longueur);
  }
}
/*
 * Classe Triangle
 */ 
 
public class Triangle extends Forme {
  Point A, B,C;
  public Triangle(Point p) {
    super(p);
    // placement des points
    placerPoints(p);
  }
  
  public Triangle(Point p, String c){
    super(p, c);
    // placement des points
    placerPoints(p);
  }
  
  public void placerPoints(Point p){
      A = new Point();    
      A.setLocation(p);
      B = new Point();    
      B.setLocation(A);
      C = new Point();    
      C.setLocation(A);
      B.translate(40,60);
      C.translate(-40,60);
  }
     public void setLocation(Point p) {
      super.setLocation(p);
      // redéfinition de l'emplacement des points
      A.setLocation(p);   
      B.setLocation(A);  
      C.setLocation(A);
      B.translate(40,60);
      C.translate(-40,60);   
  }
  
    public void increase(){
    int factY = (int)((B.getY()-A.getY())*0.1f);
    int factX = (int)((C.getX()-B.getX())*0.1f);
    A.translate(0,-factY);
    B.translate(-factX,0);
    C.translate(factX,0); 
  }
  
  public void decrease(){
    int factY = (int)((B.getY()-A.getY())*0.1f);
    int factX = (int)((C.getX()-B.getX())*0.1f);
    A.translate(0,factY);
    B.translate(factX,0);
    C.translate(-factX,0); 
  }
  
  public void update() {
    fill(this.c);
    triangle((float) A.getX(), (float) A.getY(), (float) B.getX(), (float) B.getY(), (float) C.getX(), (float) C.getY());
  }  
  
   public boolean isClicked(Point M) {
    // vérifier que le triangle est cliqué
    
    PVector AB= new PVector( (int) (B.getX() - A.getX()),(int) (B.getY() - A.getY())); 
    PVector AC= new PVector( (int) (C.getX() - A.getX()),(int) (C.getY() - A.getY())); 
    PVector AM= new PVector( (int) (M.getX() - A.getX()),(int) (M.getY() - A.getY())); 
    
    PVector BA= new PVector( (int) (A.getX() - B.getX()),(int) (A.getY() - B.getY())); 
    PVector BC= new PVector( (int) (C.getX() - B.getX()),(int) (C.getY() - B.getY())); 
    PVector BM= new PVector( (int) (M.getX() - B.getX()),(int) (M.getY() - B.getY())); 
    
    PVector CA= new PVector( (int) (A.getX() - C.getX()),(int) (A.getY() - C.getY())); 
    PVector CB= new PVector( (int) (B.getX() - C.getX()),(int) (B.getY() - C.getY())); 
    PVector CM= new PVector( (int) (M.getX() - C.getX()),(int) (M.getY() - C.getY())); 
    
    if ( ((AB.cross(AM)).dot(AM.cross(AC)) >=0) && ((BA.cross(BM)).dot(BM.cross(BC)) >=0) && ((CA.cross(CM)).dot(CM.cross(CB)) >=0) ) { 
      return(true);
    }
    else
      return(false);
  }
  
  protected double perimetre() {
    //
    PVector AB= new PVector( (int) (B.getX() - A.getX()),(int) (B.getY() - A.getY())); 
    PVector AC= new PVector( (int) (C.getX() - A.getX()),(int) (C.getY() - A.getY())); 
    PVector BC= new PVector( (int) (C.getX() - B.getX()),(int) (C.getY() - B.getY())); 
    
    return( AB.mag()+AC.mag()+BC.mag()); 
  }
   
  // Calcul de l'aire du triangle par la méthode de Héron 
  protected double aire(){
    double s = perimetre()/2;
    double aire = s*(s-distance(B,C))*(s-distance(A,C))*(s-distance(A,B));
    return(sqrt((float) aire));
  }
}
 public void clean(){
   timer = 0;
   dernier = null;
   avant_dernier = null;
}
 public void command_received(String action, String forme, String couleur, String lieu){
  
  switch(action){
    case "CREER":
      if(dernier != null){
        Forme f = null;
        Click position = dernier;
        if(couleur == "INVERSE"){
          position = avant_dernier;
        }
        switch (forme){
          case "CARRE":
            f = new Rectangle(position, couleur);
            break;
          
          case "LOSANGE":
            f = new Losange(position, couleur);
            break;
          
          case "CERCLE":
            f = new Cercle(position, couleur);
            break;
          
          case "TRIANGLE":
            f = new Triangle(position, couleur);
            break;
            
          case "JACQUELINE":
            player.rewind();
            f = new Mfja(dernier, couleur);
            player.play();
          break;
        }
        if(f != null){
          formes.add(f);
          mae=FSM.AFFICHER_FORMES;
          clean();
        }
      }
      break;
      
    case "DEPLACER":
      if(dernier != null && avant_dernier != null){
        if(avant_dernier.get_forme() != null){
          avant_dernier.get_forme().setLocation(dernier);
        }
        mae=FSM.AFFICHER_FORMES;
        clean();
      }
      break;
      
    case "SUPPRIMER":
      if(dernier != null){
        formes.remove(dernier.get_forme());
      }
      mae=FSM.AFFICHER_FORMES;
      clean();
      break;

    case "COULEUR":
      if(dernier != null){
        if(dernier.is_linked()){
          switch(couleur){
            case "ROUGE" : dernier.get_forme().setColor(color(255, 0, 0)); break;
            case "VERT" : dernier.get_forme().setColor(color(0, 255, 0));  break;
            case "BLEU" : dernier.get_forme().setColor(color(0, 0, 255));  break;
            default: dernier.get_forme().setColor(color(random(0,255),random(0,255),random(0,255)));
          }
          if(dernier.get_forme() instanceof Mfja){
            player.rewind();
            player.play();
          }
        }
      }
      mae=FSM.AFFICHER_FORMES;
      clean();
      break;

    case "AGRANDIR":
      if(dernier != null){
        if(dernier.is_linked()){
          dernier.get_forme().increase();
        }
      }
      mae=FSM.AFFICHER_FORMES;
      clean();
      break;

    case "REDUIRE":    
      if(dernier != null){
        if(dernier.is_linked()){
          dernier.get_forme().decrease();
        }
      }
      mae=FSM.AFFICHER_FORMES;
      clean();
      break;

    default:
      print("commande non reconnue");
      break;
  }
}

 public void geste_received(String template,String confidence){
  last_forme = template;
  switch (mae) {
    case AFFICHER_FORMES:
      mae = FSM.ATTENTE_CLIC;
      clean();
      break;
    default :
      break;
  }
}


  public void settings() { size(800, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Palette" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
